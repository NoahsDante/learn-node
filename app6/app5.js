/**
 * Node 本身可以做到高性能的原因是基于事件系统的使用，以及对事件监听的调用上
 *
 * node 基于事件循环机制
 *
 * 本质上，当Node 启动一个服务器/文件，Node实际上是运行在一个死循环中
 *
 * while(true) {
 *   ...
 * }
 * 在这死循环中，Node会不断的发射事件、监听事件并执行回调
 *
 * 事件来源主要有两种：一：Node自身的事件（http...），二：Node所运行的环境（操作系统）
 * 监听事件：回调依附于相应的事件
 * 执行回调逻辑：本质上都是由底层来执行的
 *
 * 关于异步IO操作执行逻辑：
 * 1. 同步模式
 * 2. 异步模块：poll epoll
 *
 * iocp libuv
 *
 * Node单线程：指Node 执行逻辑的主线程，即JavaScript代码运行的线程。
 *
 * 当引入某个第三方模块时，整体的全部执行逻辑如下所示：
 *  Node =》 第三个模块 =》 原生模块 =》 原生模块内部实现 =》 c++ 模块 =》 libuv =》 线程池 =》 线程 =》执行IO操作（涉及到操作系统调用）
 *
 * 当Node执行，会判断当前操作系统类型
 *
 * Node 事件循环机制
 * 1. 启动Node 运行
 * 2. 检查是否还有待处理事件
 * 3. 如果没有，回到循环开始
 * 4. 如果有，从事件队列中取出一个事件
 * 5. 判断当前事件是否有，事件处理器（回调）
 * 6. 如果没有，回到循环开始
 * 7. 如果有，则执行事件处理逻辑
 * 8. 回到循环开始，开始新一轮的循环
 *
 *
 * Node 整个执行过程是由 事件循环机制 + 底层异步IO操作 + 线程池（操作系统提供）共同合作执行的
 *
 * Node 是否可以利用多核的优势；
 * 对于主线程来说，它只能运行在一个核心上，
 * 对于底层线程池来说，他们可以运行在多个核心上
 *
 *
 *
 */
